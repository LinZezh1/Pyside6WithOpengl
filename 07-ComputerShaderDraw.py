import sys
import numpy as np
from PySide6.QtWidgets import QApplication, QMainWindow
from PySide6.QtOpenGLWidgets import QOpenGLWidget
# 导入 Qt, QTimer, 和修正所需的 QElapsedTimer
from PySide6.QtCore import Qt, QTimer, QElapsedTimer
from PySide6.QtGui import QSurfaceFormat, QOpenGLContext

# test：使用 Computer Shader 绘制一些纹理效果
# Check dependencies (same as before)
try:
    from OpenGL.GL import *
    # Perform a more robust check for necessary functions
    required_gl_funcs = ['glDispatchCompute', 'GL_COMPUTE_SHADER', 'glBindImageTexture',
                         'glTexStorage2D', 'glMemoryBarrier', 'GL_SHADER_IMAGE_ACCESS_BARRIER_BIT',
                         'glGenVertexArrays', 'glBindVertexArray', 'glGenBuffers', 'glBindBuffer',
                         'glBufferData', 'glVertexAttribPointer', 'glEnableVertexAttribArray',
                         'glUseProgram', 'glActiveTexture', 'glBindTexture', 'glUniform1i',
                         'glDrawElements', 'GL_RGBA8']
    missing_funcs = [func for func in required_gl_funcs if not hasattr(OpenGL.GL, func)]
    if missing_funcs:
         print(f"WARNING: PyOpenGL seems installed, but might lack necessary functions: {', '.join(missing_funcs)}")
         print("This often indicates an issue with OpenGL drivers (require 4.3+) or PyOpenGL installation.")
except ImportError:
    print("ERROR: PyOpenGL is not installed. Please install it: pip install PyOpenGL PyOpenGL_accelerate")
    sys.exit(1)
try:
    import numpy as np
except ImportError:
    print("ERROR: NumPy is not installed. Please install it: pip install numpy")
    sys.exit(1)

# == Shader Sources ==

# -- Compute Shader --
# Generates a texture pattern based on time
COMPUTE_SHADER_SRC = """
#version 430 core

// Output texture (image) - must match format in glTexStorage2D and binding in glBindImageTexture
// rgba8 means 8 bits per channel for Red, Green, Blue, Alpha
layout (rgba8, binding = 0) uniform writeonly image2D destTex;

// Input uniform for animation
uniform float time;

// Work group size (e.g., 8x8 = 64 invocations per group)
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    // Get the pixel coordinates this invocation is responsible for
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

    // Get the dimensions of the image
    ivec2 size = imageSize(destTex);

    // Boundary check (important!)
    if (pixelCoords.x >= size.x || pixelCoords.y >= size.y) {
        return;
    }

    // Calculate a simple color pattern based on coordinates and time
    float normX = float(pixelCoords.x) / float(size.x);
    float normY = float(pixelCoords.y) / float(size.y);
    float sinT = sin(time * 2.0 + normX * 5.0);
    float cosT = cos(time * 1.5 + normY * 6.0);
    vec4 color = vec4(0.5 + 0.5 * sinT,      // Red
                      0.5 + 0.5 * cosT,      // Green
                      0.5 + 0.5 * cos(time), // Blue
                      1.0);                  // Alpha

    // Write the color to the destination texture
    imageStore(destTex, pixelCoords, color);
}
"""

# -- Vertex Shader (for rendering the textured quad) --
RENDER_VERTEX_SHADER_SRC = """
#version 330 core
layout (location = 0) in vec2 aPos;      // Vertex position (NDC)
layout (location = 1) in vec2 aTexCoord; // Texture coordinate

out vec2 TexCoord; // Pass texture coordinate to fragment shader

void main() {
    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); // Output vertex position
    TexCoord = aTexCoord;                       // Pass along texture coordinate
}
"""

# -- Fragment Shader (for rendering the textured quad) --
RENDER_FRAGMENT_SHADER_SRC = """
#version 330 core
out vec4 FragColor; // Output fragment color

in vec2 TexCoord; // Input texture coordinate from vertex shader

// Sampler for the texture generated by the compute shader
uniform sampler2D computeOutputTexture;

void main() {
    // Sample the texture at the interpolated coordinate
    FragColor = texture(computeOutputTexture, TexCoord);
}
"""


class OpenGLWidget(QOpenGLWidget):
    def __init__(self, parent=None):
        super(OpenGLWidget, self).__init__(parent)
        self.compute_program = None
        self.render_program = None
        self.texture_id = None
        self.quad_vao = None
        self.quad_vbo = None
        self.quad_ebo = None # Added missing member variable initialization
        self.time_uniform_location_compute = -1
        self.texture_uniform_location_render = -1
        self.texture_width = 512 # Fixed texture size
        self.texture_height = 512
        # CORRECTION: Use QElapsedTimer to measure elapsed time
        self.start_time = QElapsedTimer()
        self.current_time = 0.0

        # Setup timer for animation updates (~60 FPS)
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update) # update() calls paintGL()


    def initializeGL(self):
        context = QOpenGLContext.currentContext()
        version_profile = context.format()
        print(f"OpenGL Version Initialized: {version_profile.majorVersion()}.{version_profile.minorVersion()} Profile: {'Core' if version_profile.profile() == QSurfaceFormat.CoreProfile else 'Compatibility'}")

        if version_profile.majorVersion() < 4 or (version_profile.majorVersion() == 4 and version_profile.minorVersion() < 3):
            print("\nCRITICAL ERROR: OpenGL version 4.3+ required.")
            QApplication.instance().quit()
            return

        glClearColor(0.1, 0.1, 0.1, 1.0) # Dark grey background

        print("Compiling Shaders...")
        self.compute_program = self.compileShader(COMPUTE_SHADER_SRC, GL_COMPUTE_SHADER, "Compute")
        self.render_program = self.compileShader(RENDER_VERTEX_SHADER_SRC, GL_VERTEX_SHADER, "Render Vertex",
                                                  RENDER_FRAGMENT_SHADER_SRC, GL_FRAGMENT_SHADER, "Render Fragment")

        if not self.compute_program or not self.render_program:
             print("Shader compilation failed. Exiting.")
             QApplication.instance().quit()
             return

        # Get uniform locations (check for errors)
        self.time_uniform_location_compute = glGetUniformLocation(self.compute_program, "time")
        self.texture_uniform_location_render = glGetUniformLocation(self.render_program, "computeOutputTexture")
        if self.time_uniform_location_compute == -1:
            print("Warning: 'time' uniform not found in compute shader.")
        if self.texture_uniform_location_render == -1:
            print("Warning: 'computeOutputTexture' uniform not found in render shader.")


        print("Setting up Texture...")
        self.setupTexture()
        print("Setting up Quad...")
        self.setupQuad()

        print("Initialization Complete. Starting timers...")
        # Start timers after successful initialization
        self.timer.start(16)
        self.start_time.start() # Start timer for elapsed time


    def compileShader(self, src1, type1, name1, src2=None, type2=None, name2=None):
        """ Compiles compute shader or vertex/fragment shader pair. """
        shader1 = glCreateShader(type1)
        glShaderSource(shader1, src1)
        glCompileShader(shader1)
        if not glGetShaderiv(shader1, GL_COMPILE_STATUS):
            log = glGetShaderInfoLog(shader1).decode() if glGetShaderInfoLog(shader1) else "No error log"
            print(f"{name1} Shader compilation error:\n", log)
            glDeleteShader(shader1)
            return None

        program = glCreateProgram()
        glAttachShader(program, shader1)

        shader2 = None
        if src2 and type2 and name2:
            shader2 = glCreateShader(type2)
            glShaderSource(shader2, src2)
            glCompileShader(shader2)
            if not glGetShaderiv(shader2, GL_COMPILE_STATUS):
                log = glGetShaderInfoLog(shader2).decode() if glGetShaderInfoLog(shader2) else "No error log"
                print(f"{name2} Shader compilation error:\n", log)
                glDeleteShader(shader1)
                glDeleteShader(shader2)
                glDeleteProgram(program)
                return None
            glAttachShader(program, shader2)

        glLinkProgram(program)
        if not glGetProgramiv(program, GL_LINK_STATUS):
            log = glGetProgramInfoLog(program).decode() if glGetProgramInfoLog(program) else "No error log"
            print("Shader Program linking error:\n", log)
            glDeleteShader(shader1)
            if shader2: glDeleteShader(shader2)
            glDeleteProgram(program)
            return None

        # Detach and delete shaders after successful link
        glDetachShader(program, shader1)
        glDeleteShader(shader1)
        if shader2:
             glDetachShader(program, shader2)
             glDeleteShader(shader2)

        print(f"{name1}{' & ' + name2 if name2 else ''} Shaders compiled and linked successfully.")
        return program

    def setupTexture(self):
        self.texture_id = glGenTextures(1)
        glBindTexture(GL_TEXTURE_2D, self.texture_id)

        # Define texture storage (immutable) - Use GL_RGBA8 format matching the compute shader layout
        # Levels = 1 means no mipmaps are generated or needed
        glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, self.texture_width, self.texture_height)

        # Set texture parameters (important for non-mipmapped textures)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR) # Minification filter
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR) # Magnification filter
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE) # Wrap mode S
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE) # Wrap mode T

        # Unbind texture
        glBindTexture(GL_TEXTURE_2D, 0)
        print(f"Texture created (ID: {self.texture_id}) with size {self.texture_width}x{self.texture_height}")

    def setupQuad(self):
        # Vertices for a full-screen quad in Normalized Device Coordinates (NDC)
        # Position (x, y) TexCoord (s, t)
        quad_vertices = np.array([
            # Position      TexCoord
            -1.0, -1.0,     0.0, 0.0, # Bottom Left
             1.0, -1.0,     1.0, 0.0, # Bottom Right
             1.0,  1.0,     1.0, 1.0, # Top Right
            -1.0,  1.0,     0.0, 1.0  # Top Left
        ], dtype=np.float32)

        # Indices to draw two triangles forming the quad
        quad_indices = np.array([
            0, 1, 2, # First Triangle
            2, 3, 0  # Second Triangle
        ], dtype=np.uint32) # Use unsigned int for indices

        self.quad_vao = glGenVertexArrays(1)
        self.quad_vbo = glGenBuffers(1)
        self.quad_ebo = glGenBuffers(1) # Element Buffer Object for indices

        glBindVertexArray(self.quad_vao)

        # Upload vertex data
        glBindBuffer(GL_ARRAY_BUFFER, self.quad_vbo)
        glBufferData(GL_ARRAY_BUFFER, quad_vertices.nbytes, quad_vertices, GL_STATIC_DRAW)

        # Upload index data
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.quad_ebo)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, quad_indices.nbytes, quad_indices, GL_STATIC_DRAW)

        # Define layout for shader locations
        POS_LOCATION = 0
        TEX_LOCATION = 1

        # Configure vertex attributes
        # Position attribute (location = 0)
        stride = 4 * sizeof(GLfloat) # 2 floats for pos, 2 floats for texcoord
        glVertexAttribPointer(POS_LOCATION, 2, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(0))
        glEnableVertexAttribArray(POS_LOCATION)
        # Texture coordinate attribute (location = 1)
        glVertexAttribPointer(TEX_LOCATION, 2, GL_FLOAT, GL_FALSE, stride, ctypes.c_void_p(2 * sizeof(GLfloat)))
        glEnableVertexAttribArray(TEX_LOCATION)

        # Unbind VAO first. VAO stores the EBO binding.
        glBindVertexArray(0)
        # Unbind other buffers after unbinding VAO.
        glBindBuffer(GL_ARRAY_BUFFER, 0)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)


        print("Quad VAO/VBO/EBO setup complete.")


    def resizeGL(self, width, height):
        if height == 0: height = 1
        glViewport(0, 0, width, height)
        # If texture size depended on window size, you'd resize/recreate it here

    def paintGL(self):
        if not self.compute_program or not self.render_program or not self.texture_id or not self.quad_vao:
            # print("paintGL called before initialization complete.") # Optional debug print
            return # Not initialized yet

        # --- Update Time ---
        # CORRECTION: Use QElapsedTimer's elapsed() method
        self.current_time = self.start_time.elapsed() / 1000.0 # Time in seconds


        # --- Compute Phase ---
        glUseProgram(self.compute_program)

        # Update time uniform
        if self.time_uniform_location_compute != -1:
            glUniform1f(self.time_uniform_location_compute, self.current_time)
        else:
             # print("Time uniform location invalid") # Optional debug
             pass

        # Bind the texture to an image unit (unit 0) for writing
        # Level 0, not layered, no specific layer, write-only access, internal format GL_RGBA8
        glBindImageTexture(0, self.texture_id, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8)

        # Dispatch compute shader
        # Calculate number of work groups needed based on texture size and local_size defined in shader
        local_size_x = 8
        local_size_y = 8 # Must match shader!
        num_groups_x = (self.texture_width + local_size_x - 1) // local_size_x
        num_groups_y = (self.texture_height + local_size_y - 1) // local_size_y
        glDispatchCompute(num_groups_x, num_groups_y, 1) # Dispatch in X and Y

        # ** CRITICAL BARRIER **
        # Ensure imageStore operations are complete before the texture is sampled
        glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT)

        # Unbind image texture (good practice, though not strictly necessary if next step rebinds)
        # glBindImageTexture(0, 0, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8) # Can be commented out


        # --- Render Phase ---
        # Set viewport (optional here if resizeGL handles it, but good practice)
        # glViewport(0, 0, self.width(), self.height()) # Use actual widget size
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # Clear screen

        glUseProgram(self.render_program)

        # Bind the texture for sampling
        glActiveTexture(GL_TEXTURE0) # Activate texture unit 0
        glBindTexture(GL_TEXTURE_2D, self.texture_id)

        # Tell the sampler uniform to use texture unit 0
        if self.texture_uniform_location_render != -1:
            glUniform1i(self.texture_uniform_location_render, 0)
        else:
            # print("Texture uniform location invalid") # Optional debug
            pass

        # Bind the VAO for the quad
        glBindVertexArray(self.quad_vao)

        # Draw the quad (6 indices)
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, None) # Use indices from bound EBO

        # Unbind resources
        glBindVertexArray(0)
        glBindTexture(GL_TEXTURE_2D, 0) # Unbind texture from texture unit 0
        glUseProgram(0)


    def cleanupGL(self):
        print("Cleaning up GL resources...")
        # Make context current MUST be called before deleting GL objects
        # Check if context is valid before making current
        if self.context().isValid():
             self.makeCurrent()
             # Use hasattr for safety in case variables weren't initialized
             if hasattr(self, 'quad_ebo') and self.quad_ebo:
                  print(f"Deleting EBO: {self.quad_ebo}")
                  glDeleteBuffers(1, [self.quad_ebo])
                  self.quad_ebo = None
             if hasattr(self, 'quad_vbo') and self.quad_vbo:
                  print(f"Deleting VBO: {self.quad_vbo}")
                  glDeleteBuffers(1, [self.quad_vbo])
                  self.quad_vbo = None
             if hasattr(self, 'quad_vao') and self.quad_vao:
                  print(f"Deleting VAO: {self.quad_vao}")
                  glDeleteVertexArrays(1, [self.quad_vao])
                  self.quad_vao = None
             if hasattr(self, 'texture_id') and self.texture_id:
                  print(f"Deleting Texture: {self.texture_id}")
                  glDeleteTextures(1, [self.texture_id])
                  self.texture_id = None
             if hasattr(self, 'compute_program') and self.compute_program:
                  print(f"Deleting Compute Program: {self.compute_program}")
                  glDeleteProgram(self.compute_program)
                  self.compute_program = None
             if hasattr(self, 'render_program') and self.render_program:
                  print(f"Deleting Render Program: {self.render_program}")
                  glDeleteProgram(self.render_program)
                  self.render_program = None
             self.doneCurrent() # Release context
             print("Cleanup attempt finished.")
        else:
             print("OpenGL context invalid, skipping cleanup.")


    # Make sure cleanup is called when widget is destroyed
    # def __del__(self):
    #     print(f"OpenGLWidget __del__ called for {id(self)}")
    #     # This is often unreliable for GL cleanup due to context issues
    #     # self.cleanupGL()
    #     pass


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle("PySide6 Compute Shader -> Texture -> Render")
        self.setGeometry(100, 100, 600, 600) # Adjusted size

        self.gl_widget = OpenGLWidget()
        self.setCentralWidget(self.gl_widget)

    def closeEvent(self, event):
        print("MainWindow closing...")
        # Explicitly call the cleanup method on the contained widget
        # This ensures the GL context is likely still available and current
        self.gl_widget.cleanupGL()
        super().closeEvent(event)


if __name__ == "__main__":
    # Enable high DPI scaling for better visuals on relevant displays
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)

    gl_format = QSurfaceFormat()
    print("Requesting OpenGL 4.3 Core Profile...")
    gl_format.setVersion(4, 3)
    gl_format.setProfile(QSurfaceFormat.CoreProfile)
    # Optional: Request depth buffer size, etc.
    # gl_format.setDepthBufferSize(24)
    QSurfaceFormat.setDefaultFormat(gl_format)

    app = QApplication(sys.argv)

    print("Creating MainWindow...")
    window = MainWindow()
    window.show()
    print("Starting application event loop...")
    sys.exit(app.exec())